# INFO: THIS WORKFLOW DEPLOYS MINIMAL API TO AWS LAMBDA AND CONFIGURES API GATEWAY WITH AWS CLI
# INFO: IAM USER REQUIRES PERMISSIONS TO EXECUTE THIS WORKFLOW (SEE IN FILE '.github/aws/iam-user-policy.json' AND 'README.md' FOR DETAILS)
# INFO: ROLES CREATED BY THIS WORKFLOW ARE USED BY LAMBDA AND API GATEWAY FOR THEIR OPERATIONS (OPTIMIZED FOR SECURITY)
# INFO: THIS WORKFLOW PRESERVES API GATEWAY ID ACROSS RUNS TO MAINTAIN CONSISTENT API ENDPOINTS
# INFO: USAGE PLANS AND API KEYS ARE REUSED WHEN THEY ALREADY EXIST TO PREVENT CONFLICTS
# INFO: PROPER ERROR HANDLING IS IMPLEMENTED TO ENSURE SMOOTH DEPLOYMENT EVEN WHEN RESOURCES ALREADY EXIST
# INFO: GITHUB ACTIONS ANNOTATIONS ARE USED TO DISPLAY IMPORTANT INFORMATION LIKE API GATEWAY URL
# INFO: ENHANCED SECURITY MEASURES ARE IN PLACE INCLUDING LEAST PRIVILEGE ACCESS AND RESOURCE MASKING
# INFO: API GATEWAY CONFIGURED WITH UNIVERSAL CORS FOR MICROSERVICE USAGE ACROSS MULTIPLE PROJECTS

# WARN: THERE IS DUPLICATION BETWEEN IAM USER PERMISSIONS AND THOSE OF CREATED ROLES
# WARN: THIS DUPLICATION MAKES SOME PERMISSIONS IN ROLES REDUNDANT BECAUSE IAM USER ALREADY HAS THESE PERMISSIONS
# WARN: THIS APPROACH IS NOT OPTIMAL FROM A SECURITY PERSPECTIVE (PRINCIPLE OF LEAST PRIVILEGE)
# WARN: API GATEWAY ID IS VISIBLE IN LOGS BECAUSE URL ARE PUBLIC BUT API KEY IS PROPERLY MASKED FOR SECURITY
# WARN: USAGE PLAN ASSOCIATION MIGHT FAIL IF THE API STAGE IS ALREADY ASSOCIATED WITH ANOTHER USAGE PLAN

# TODO FIX: TO OPTIMIZE SECURITY, CONSIDER:
# FIX: 1. LIMITING IAM USER TO ONLY PERMISSIONS NECESSARY TO CREATE/MANAGE ROLES
# FIX: 2. ENSURING THAT CREATED ROLES HAVE SPECIFIC PERMISSIONS FOR THEIR RESPECTIVE TASKS
# FIX: 3. USING SPECIFIC ARNS IN POLICIES RATHER THAN "*" TO LIMIT SCOPE OF PERMISSIONS
# FIX: 4. IMPLEMENTING PROPER CLEANUP OF UNUSED RESOURCES TO PREVENT ACCUMULATION

name: Deploy to AWS Lambda

on:
  workflow_dispatch:
    inputs:
      run_tests:
        description: "Run tests before deployment"
        type: boolean
        default: false
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # PROJECT-SPECIFIC SETTINGS - CUSTOMIZABLE
  DEFAULT_FUNCTION_NAME: "template-demo-deploy-minimal-api"
  DEFAULT_RESOURCE_PREFIX: "template-demo-deploy-minimal-api-"
  DEFAULT_PROJECT_PATH: "Demo/WeatherForecast"
  DEFAULT_TESTS_PATH: "Demo/WeatherForecast.Tests"
  DEFAULT_LAMBDA_HANDLER: "WeatherForecast::WeatherForecast.LambdaEntryPoint::FunctionHandlerAsync"
  DEFAULT_API_GATEWAY_TYPE: "REST" # OPTIONS: REST OR HTTP

  # PROJECT ENVIRONMENT VARIABLES
  DEFAULT_PROJECT_ENV: "{{ env.CUSTOM_ENV_VAR }};{{ env.CUSTOM_ENV_VAR_2 }}"

  # AWS DEPLOYMENT CONFIGURATION - ADJUST THESE FOR PERFORMANCE/COST BALANCE
  DEFAULT_REGION: "us-east-1"
  DEFAULT_DOTNET_VERSION: "8.0.x"
  DEFAULT_MEMORY: "512" # MEMORY IN MB
  DEFAULT_TIMEOUT: "30" # TIMEOUT IN SECONDS
  DEFAULT_THROTTLE_RATE: "10" # REQUESTS PER SECOND
  DEFAULT_THROTTLE_BURST: "20" # MAX CONCURRENT REQUESTS
  DEFAULT_QUOTA_LIMIT: "1000" # MAX REQUESTS PER PERIOD
  DEFAULT_QUOTA_PERIOD: "DAY" # QUOTA PERIOD (DAY, WEEK, MONTH)

  # DOTNET BUILD SETTINGS - TYPICALLY NO NEED TO MODIFY
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

run-name: "Deploy to AWS Lambda"
permissions:
  id-token: write
  contents: read
  packages: read

jobs:
  create-github-role:
    name: Create GitHub OIDC role
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      role_arn: ${{ steps.create-oidc-role.outputs.role_arn }}
      role_exists: ${{ steps.check-role-exists.outputs.exists }}

    steps:
      - name: Set variables
        run: |
          # SET VARIABLES DIRECTLY FROM DEFAULTS
          echo "FUNCTION_NAME=$DEFAULT_FUNCTION_NAME" >> $GITHUB_ENV
          echo "RESOURCE_PREFIX=$DEFAULT_RESOURCE_PREFIX" >> $GITHUB_ENV
          echo "AWS_REGION=$DEFAULT_REGION" >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials with access key
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION || 'us-east-1' }}

      - name: Check if GitHub OIDC role already exists
        id: check-role-exists
        run: |
          echo "TESTING AWS CREDENTIALS..."
          # GET ACCOUNT ID WITHOUT DISPLAYING IT
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "::add-mask::$ACCOUNT_ID"
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV

          ROLE_NAME="${{ env.RESOURCE_PREFIX }}github-actions-role"
          ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.Arn' --output text 2>/dev/null || echo "")
          echo "::add-mask::$ROLE_ARN"

          if [ -n "$ROLE_ARN" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "::notice::GITHUB OIDC ROLE ALREADY EXISTS. REUSING EXISTING ROLE."
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Actions role
        id: create-oidc-role
        if: steps.check-role-exists.outputs.exists != 'true'
        run: |
          # CREATE TRUST POLICY
          echo '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Federated": "PROVIDER_ARN_PLACEHOLDER"
                },
                "Action": "sts:AssumeRoleWithWebIdentity",
                "Condition": {
                  "StringLike": {
                    "token.actions.githubusercontent.com:sub": "repo:${{ github.repository }}:*"
                  }
                }
              }
            ]
          }' > trust-policy-template.json

          # CREATE POLICY
          echo '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "iam:CreateRole",
                  "iam:GetRole",
                  "iam:PutRolePolicy",
                  "iam:AttachRolePolicy",
                  "iam:ListRolePolicies",
                  "iam:ListAttachedRolePolicies"
                ],
                "Resource": [
                  "arn:aws:iam::${{ env.ACCOUNT_ID }}:role/${{ env.RESOURCE_PREFIX }}*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "lambda:CreateFunction",
                  "lambda:GetFunction",
                  "lambda:UpdateFunctionCode",
                  "lambda:UpdateFunctionConfiguration",
                  "lambda:AddPermission",
                  "lambda:DeleteFunction"
                ],
                "Resource": "arn:aws:lambda:${{ env.AWS_REGION }}:${{ env.ACCOUNT_ID }}:function:${{ env.FUNCTION_NAME }}"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "apigateway:GET",
                  "apigateway:POST",
                  "apigateway:PUT",
                  "apigateway:DELETE"
                ],
                "Resource": [
                  "arn:aws:apigateway:${{ env.AWS_REGION }}::/restapis",
                  "arn:aws:apigateway:${{ env.AWS_REGION }}::/restapis/*"
                ]
              }
            ]
          }' > policy.json

          # GET PROVIDER ARN WITHOUT DISPLAYING IT
          PROVIDER_ARN=$(aws iam list-open-id-connect-providers --query 'OpenIDConnectProviderList[?contains(Arn, `token.actions.githubusercontent.com`)].Arn' --output text)
          echo "::add-mask::$PROVIDER_ARN"

          if [ -z "$PROVIDER_ARN" ]; then
            echo "CREATING GITHUB OIDC PROVIDER..."
            THUMBPRINT=$(curl -s https://token.actions.githubusercontent.com/.well-known/openid-configuration | jq -r '.jwks_uri' | xargs curl -s | jq -r '.keys[0].x5c[0]' | base64 -d | openssl x509 -noout -fingerprint -sha1 | cut -d'=' -f2 | tr -d ':')
            PROVIDER_ARN=$(aws iam create-open-id-connect-provider --url "https://token.actions.githubusercontent.com" --client-id-list "sts.amazonaws.com" --thumbprint-list "$THUMBPRINT" --query 'OpenIDConnectProviderArn' --output text)
            echo "::add-mask::$PROVIDER_ARN"
          fi

          ROLE_NAME="${{ env.RESOURCE_PREFIX }}github-actions-role"

          # DON'T DISPLAY PROVIDER ARN
          jq -n \
            --arg provider "$PROVIDER_ARN" \
            --arg repo "${{ github.repository }}" \
            '{
              Version: "2012-10-17",
              Statement: [{
                Effect: "Allow",
                Principal: {
                  Federated: $provider
                },
                Action: "sts:AssumeRoleWithWebIdentity",
                Condition: {
                  StringLike: {
                    "token.actions.githubusercontent.com:sub": ("repo:" + $repo + ":*")
                  }
                }
              }]
            }' > trust-policy.json
            
          ROLE_ARN=$(aws iam create-role --role-name "$ROLE_NAME" --assume-role-policy-document file://trust-policy.json --query 'Role.Arn' --output text)
          echo "::add-mask::$ROLE_ARN"
            
          aws iam put-role-policy --role-name "$ROLE_NAME" --policy-name "${RESOURCE_PREFIX}github-actions-policy" --policy-document file://policy.json
          echo "WAITING FOR ROLE PROPAGATION..."
          sleep 10

          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

  test:
    needs: create-github-role
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: ${{ github.event.inputs.run_tests == 'true' }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json', '**/packages.config') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore dependencies
        run: |
          cd ${{ env.TESTS_PATH }}
          dotnet restore

      - name: Run tests
        run: |
          cd ${{ env.TESTS_PATH }}
          dotnet test --no-restore --verbosity normal --collect:"XPlat Code Coverage" --logger "trx;LogFileName=test-results.trx"

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: ${{ env.TESTS_PATH }}/TestResults
          retention-days: 30

  build:
    needs: [create-github-role, test]
    if: |
      !failure() && !cancelled() && 
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      package_path: ${{ steps.package.outputs.package_path }}

    steps:
      - name: Check skipped jobs status
        run: |
          if [[ "${{ needs.test.result }}" == "skipped" ]]; then
            echo "::notice::TEST JOB WAS SKIPPED BECAUSE RUN_TESTS IS SET TO FALSE."
          fi

      - uses: actions/checkout@v4

      - name: Set remaining variables
        run: |
          echo "PROJECT_PATH=$DEFAULT_PROJECT_PATH" >> $GITHUB_ENV
          echo "TESTS_PATH=$DEFAULT_TESTS_PATH" >> $GITHUB_ENV
          echo "LAMBDA_HANDLER=$DEFAULT_LAMBDA_HANDLER" >> $GITHUB_ENV

          # ENVIRONMENT VARIABLES JSON
          echo "ENVIRONMENT_VARS={\"ASPNETCORE_ENVIRONMENT\":\"Production\"}" >> $GITHUB_ENV

          # BOOLEAN FLAGS
          echo "RUN_TESTS=${{ github.event.inputs.run_tests }}" >> $GITHUB_ENV
          echo "ENABLE_CORS=true" >> $GITHUB_ENV

          # SET Lambda config values
          echo "DOTNET_VERSION=$DEFAULT_DOTNET_VERSION" >> $GITHUB_ENV
          echo "LAMBDA_MEMORY=$DEFAULT_MEMORY" >> $GITHUB_ENV
          echo "LAMBDA_TIMEOUT=$DEFAULT_TIMEOUT" >> $GITHUB_ENV

          # SET API Gateway config values
          echo "API_THROTTLE_RATE=$DEFAULT_THROTTLE_RATE" >> $GITHUB_ENV
          echo "API_THROTTLE_BURST=$DEFAULT_THROTTLE_BURST" >> $GITHUB_ENV
          echo "API_QUOTA_LIMIT=$DEFAULT_QUOTA_LIMIT" >> $GITHUB_ENV
          echo "API_QUOTA_PERIOD=$DEFAULT_QUOTA_PERIOD" >> $GITHUB_ENV
          echo "API_GATEWAY_TYPE=$DEFAULT_API_GATEWAY_TYPE" >> $GITHUB_ENV

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Debug Environment Variables
        run: |
          echo "ENVIRONMENT VARIABLES:"
          echo "PROJECT_PATH=${{ env.PROJECT_PATH }}"
          echo "DOTNET_VERSION=${{ env.DOTNET_VERSION }}"
          ls -la

      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json', '**/packages.config') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Install Amazon.Lambda.Tools
        run: dotnet tool install -g Amazon.Lambda.Tools

      - name: Build and Package
        id: package
        run: |
          PROJECT_DIR="${PROJECT_PATH:-$DEFAULT_PROJECT_PATH}"
          echo "USING PROJECT DIRECTORY: $PROJECT_DIR"

          cd $PROJECT_DIR
          dotnet restore
          dotnet build -c Release --no-restore
          dotnet publish -c Release -o ./publish --no-restore
          dotnet lambda package --configuration Release --framework net8.0 --output-package bin/Release/net8.0/lambda-package.zip
          echo "package_path=bin/Release/net8.0/lambda-package.zip" >> $GITHUB_OUTPUT

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-package
          path: ${{ env.PROJECT_PATH }}/bin/Release/net8.0/lambda-package.zip

  create-iam-roles:
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: ${{ !failure() && !cancelled() }}
    outputs:
      lambda_role_arn: ${{ steps.create-lambda-role.outputs.role_arn }}
      role_exists: ${{ steps.check-lambda-role-exists.outputs.exists }}

    steps:
      - name: Set variables
        run: |
          # SET variables directly from defaults
          echo "FUNCTION_NAME=$DEFAULT_FUNCTION_NAME" >> $GITHUB_ENV
          echo "RESOURCE_PREFIX=$DEFAULT_RESOURCE_PREFIX" >> $GITHUB_ENV
          echo "AWS_REGION=$DEFAULT_REGION" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION || 'us-east-1' }}

      - name: Check if Lambda role already exists
        id: check-lambda-role-exists
        run: |
          # GET AWS ACCOUNT ID
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "::add-mask::$ACCOUNT_ID"
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV

          # CHECK IF LAMBDA ROLE EXISTS
          ROLE_NAME="${{ env.RESOURCE_PREFIX }}lambda-exec-role"
          ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.Arn' --output text 2>/dev/null || echo "")
          echo "::add-mask::$ROLE_ARN"

          if [ -n "$ROLE_ARN" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "::notice::LAMBDA EXECUTION ROLE ALREADY EXISTS. REUSING EXISTING ROLE."
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Lambda execution role
        id: create-lambda-role
        if: steps.check-lambda-role-exists.outputs.exists != 'true'
        run: |
          ROLE_NAME="${{ env.RESOURCE_PREFIX }}lambda-exec-role"
          echo "CREATING LAMBDA EXECUTION ROLE..."
          echo '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"lambda.amazonaws.com"},"Action":"sts:AssumeRole"}]}' > trust-policy.json
          ROLE_ARN=$(aws iam create-role --role-name "$ROLE_NAME" --assume-role-policy-document file://trust-policy.json --query 'Role.Arn' --output text)
          echo "::add-mask::$ROLE_ARN"
          aws iam attach-role-policy --role-name "$ROLE_NAME" --policy-arn "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole" > /dev/null

          # LEAST PRIVILEGED POLICY (SPECIFIC ARNS)
          echo '{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "logs:CreateLogGroup",
                  "logs:CreateLogStream",
                  "logs:PutLogEvents"
                ],
                "Resource": [
                  "arn:aws:logs:${{ env.AWS_REGION }}:${{ env.ACCOUNT_ID }}:log-group:/aws/lambda/${{ env.FUNCTION_NAME }}:*"
                ]
              }
            ]
          }' > lambda-policy.json

          aws iam put-role-policy --role-name "$ROLE_NAME" --policy-name "${{ env.RESOURCE_PREFIX }}lambda-policy" --policy-document file://lambda-policy.json > /dev/null
          echo "WAITING FOR ROLE PROPAGATION..."
          sleep 10

          # STORE ROLE ARN IN OUTPUT WITHOUT DISPLAYING IT
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [build, create-iam-roles]
    if: ${{ !failure() && !cancelled() }}
    env:
      LAMBDA_PACKAGE_PATH: lambda-package.zip

    steps:
      - name: Set variables
        run: |
          # SET variables directly from defaults
          echo "FUNCTION_NAME=$DEFAULT_FUNCTION_NAME" >> $GITHUB_ENV
          echo "RESOURCE_PREFIX=$DEFAULT_RESOURCE_PREFIX" >> $GITHUB_ENV
          echo "PROJECT_PATH=$DEFAULT_PROJECT_PATH" >> $GITHUB_ENV
          echo "TESTS_PATH=$DEFAULT_TESTS_PATH" >> $GITHUB_ENV
          echo "LAMBDA_HANDLER=$DEFAULT_LAMBDA_HANDLER" >> $GITHUB_ENV

          # ENVIRONMENT variables JSON
          echo "ENVIRONMENT_VARS={\"ASPNETCORE_ENVIRONMENT\":\"Production\"}" >> $GITHUB_ENV

          # BOOLEAN flags
          echo "RUN_TESTS=${{ github.event.inputs.run_tests }}" >> $GITHUB_ENV
          echo "ENABLE_CORS=true" >> $GITHUB_ENV

          # SET CONFIG VALUES
          echo "AWS_REGION=$DEFAULT_REGION" >> $GITHUB_ENV
          echo "DOTNET_VERSION=$DEFAULT_DOTNET_VERSION" >> $GITHUB_ENV
          echo "LAMBDA_MEMORY=$DEFAULT_MEMORY" >> $GITHUB_ENV
          echo "LAMBDA_TIMEOUT=$DEFAULT_TIMEOUT" >> $GITHUB_ENV

          # SET API GATEWAY CONFIG VALUES
          echo "API_THROTTLE_RATE=$DEFAULT_THROTTLE_RATE" >> $GITHUB_ENV
          echo "API_THROTTLE_BURST=$DEFAULT_THROTTLE_BURST" >> $GITHUB_ENV
          echo "API_QUOTA_LIMIT=$DEFAULT_QUOTA_LIMIT" >> $GITHUB_ENV
          echo "API_QUOTA_PERIOD=$DEFAULT_QUOTA_PERIOD" >> $GITHUB_ENV
          echo "API_GATEWAY_TYPE=$DEFAULT_API_GATEWAY_TYPE" >> $GITHUB_ENV

      - name: Debug Info
        run: |
          echo "JOB DEPLOY IS RUNNING!"
          echo "AWS_REGION=${{ env.AWS_REGION }}"
          echo "AWS_ACCESS_KEY_ID EXISTS: ${{ secrets.AWS_ACCESS_KEY_ID != '' }}"
          echo "AWS_SECRET_ACCESS_KEY EXISTS: ${{ secrets.AWS_SECRET_ACCESS_KEY != '' }}"

      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION || 'us-east-1' }}

      - name: Get Lambda Execution Role
        run: |
          ROLE_ARN="${{ needs.create-iam-roles.outputs.lambda_role_arn }}"
          if [ -z "$ROLE_ARN" ]; then
            echo "ROLE ARN WAS NOT CORRECTLY PASSED FROM THE CREATE-IAM-ROLES JOB, GETTING IT DIRECTLY..."
            ROLE_NAME="${{ env.RESOURCE_PREFIX }}lambda-exec-role"
            ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.Arn' --output text)
            if [[ "${{ needs.create-iam-roles.result }}" == "skipped" ]]; then
              echo "::notice::IAM ROLES JOB WAS SKIPPED BECAUSE LAMBDA EXECUTION ROLE ALREADY EXISTS AND IS BEING REUSED."
            fi
          fi
          echo "::add-mask::$ROLE_ARN"
          echo "LAMBDA_ROLE_ARN=$ROLE_ARN" >> $GITHUB_ENV

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Get AWS Account ID
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "::add-mask::$ACCOUNT_ID"
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV

      - name: Install Amazon.Lambda.Tools
        run: dotnet tool install -g Amazon.Lambda.Tools

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: lambda-package
          path: ${{ env.PROJECT_PATH }}/

      - name: Verify package exists
        run: |
          if [ ! -f "$PROJECT_PATH/${{ env.LAMBDA_PACKAGE_PATH }}" ]; then
            echo "PACKAGE NOT FOUND AT $PROJECT_PATH/${{ env.LAMBDA_PACKAGE_PATH }}"
            ls -la $PROJECT_PATH/
            exit 1
          fi

      - name: Deploy Lambda function
        run: |
          cd ${{ env.PROJECT_PATH }}

          # DEPLOYING WITH THE RETRIEVED ROLE ARN
          echo "DEPLOYING WITH AWS CREDENTIALS..."
          dotnet lambda deploy-function ${{ env.FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --function-role "${{ env.LAMBDA_ROLE_ARN }}" \
            --function-handler ${{ env.LAMBDA_HANDLER }} \
            --package lambda-package.zip \
            --function-memory-size ${{ env.LAMBDA_MEMORY }} \
            --function-timeout ${{ env.LAMBDA_TIMEOUT }} \
            --function-runtime dotnet8 \
            --function-environment-variables "ASPNETCORE_ENVIRONMENT=Production;${{ env.DEFAULT_PROJECT_ENV }};LAMBDA_DEBUG=true" \
            --disable-interactive true

      - name: Set API Gateway variables
        run: |
          # API GATEWAY ID/name variables
          echo "API_NAME=${{ env.RESOURCE_PREFIX }}api" >> $GITHUB_ENV
          echo "API_DESCRIPTION=API for ${{ env.FUNCTION_NAME }}" >> $GITHUB_ENV

          # USAGE PLAN VARIABLES
          echo "USAGE_PLAN_NAME=${{ env.RESOURCE_PREFIX }}usage-plan" >> $GITHUB_ENV
          echo "USAGE_PLAN_DESCRIPTION=Usage plan for ${{ env.FUNCTION_NAME }}" >> $GITHUB_ENV

          # API KEY VARIABLES
          echo "API_KEY_NAME=${{ env.RESOURCE_PREFIX }}api-key" >> $GITHUB_ENV
          echo "API_KEY_DESCRIPTION=API key for ${{ env.FUNCTION_NAME }}" >> $GITHUB_ENV

      - name: Check if API Gateway exists
        id: check-api-exists
        run: |
          # CHECK IF API ALREADY EXISTS BY LISTING ALL APIS AND FILTERING BY NAME
          API_ID=$(aws apigateway get-rest-apis --query "items[?name=='${{ env.API_NAME }}'].id" --output text)

          if [ -n "$API_ID" ]; then
            echo "API_ID=$API_ID" >> $GITHUB_ENV
            echo "::notice::REUSING EXISTING API GATEWAY WITH ID: $API_ID"
            echo "api_exists=true" >> $GITHUB_OUTPUT
          else
            echo "api_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create API Gateway
        if: steps.check-api-exists.outputs.api_exists != 'true'
        run: |
          echo "CREATING NEW API GATEWAY..."
          API_RESULT=$(aws apigateway create-rest-api \
            --name "${{ env.API_NAME }}" \
            --description "${{ env.API_DESCRIPTION }}" \
            --endpoint-configuration "types=REGIONAL")

          API_ID=$(echo $API_RESULT | jq -r '.id')
          echo "API_ID=$API_ID" >> $GITHUB_ENV
          echo "::notice::CREATED NEW API GATEWAY WITH ID: $API_ID"

      - name: Configure API Gateway
        run: |
          # GET ROOT RESOURCE ID
          ROOT_RESOURCE_ID=$(aws apigateway get-resources \
            --rest-api-id $API_ID \
            --query 'items[?path==`/`].id' \
            --output text)

          # CREATE PROXY RESOURCE
          PROXY_RESOURCE_RESULT=$(aws apigateway create-resource \
            --rest-api-id $API_ID \
            --parent-id $ROOT_RESOURCE_ID \
            --path-part "{proxy+}" 2>/dev/null || echo "Resource likely exists")

          PROXY_RESOURCE_ID=$(aws apigateway get-resources \
            --rest-api-id $API_ID \
            --query 'items[?path==`/{proxy+}`].id' \
            --output text)

          # SET UP ANY METHOD
          aws apigateway put-method \
            --rest-api-id $API_ID \
            --resource-id $PROXY_RESOURCE_ID \
            --http-method ANY \
            --authorization-type NONE 2>/dev/null || echo "Method likely exists"

          # CREATE LAMBDA INTEGRATION
          aws apigateway put-integration \
            --rest-api-id $API_ID \
            --resource-id $PROXY_RESOURCE_ID \
            --http-method ANY \
            --type AWS_PROXY \
            --integration-http-method POST \
            --uri arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:${{ env.ACCOUNT_ID }}:function:${{ env.FUNCTION_NAME }}/invocations 2>/dev/null || echo "Integration likely exists"

          # CREATE ROOT METHOD
          aws apigateway put-method \
            --rest-api-id $API_ID \
            --resource-id $ROOT_RESOURCE_ID \
            --http-method ANY \
            --authorization-type NONE 2>/dev/null || echo "Method likely exists"

          # CREATE ROOT LAMBDA INTEGRATION
          aws apigateway put-integration \
            --rest-api-id $API_ID \
            --resource-id $ROOT_RESOURCE_ID \
            --http-method ANY \
            --type AWS_PROXY \
            --integration-http-method POST \
            --uri arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/arn:aws:lambda:${{ env.AWS_REGION }}:${{ env.ACCOUNT_ID }}:function:${{ env.FUNCTION_NAME }}/invocations 2>/dev/null || echo "Integration likely exists"

          # ADD LAMBDA PERMISSION FOR API GATEWAY
          STATEMENT_ID="${{ env.RESOURCE_PREFIX }}api-gateway-permission"
          EXISTING_PERMISSIONS=$(aws lambda get-policy --function-name ${{ env.FUNCTION_NAME }} 2>/dev/null || echo "{}")

          if ! echo "$EXISTING_PERMISSIONS" | grep -q "$STATEMENT_ID"; then
            aws lambda add-permission \
              --function-name ${{ env.FUNCTION_NAME }} \
              --statement-id "$STATEMENT_ID" \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:${{ env.ACCOUNT_ID }}:$API_ID/*/*"
          fi

      - name: Deploy API
        run: |
          # CREATE DEPLOYMENT
          DEPLOYMENT_RESULT=$(aws apigateway create-deployment \
            --rest-api-id $API_ID \
            --stage-name prod \
            --description "Deployed from GitHub Actions")

          # CONFIGURE CORS IF ENABLED
          if [[ "${{ env.ENABLE_CORS }}" == "true" ]]; then
            echo "CONFIGURING CORS FOR API GATEWAY..."
            
            # GET ALL RESOURCES
            RESOURCES=$(aws apigateway get-resources \
              --rest-api-id $API_ID \
              --query 'items[].id' \
              --output text)
            
            for RESOURCE_ID in $RESOURCES; do
              # ADD OPTIONS METHOD
              aws apigateway put-method \
                --rest-api-id $API_ID \
                --resource-id $RESOURCE_ID \
                --http-method OPTIONS \
                --authorization-type NONE 2>/dev/null || echo "Method likely exists"
              
              # CONFIGURE OPTIONS RESPONSE
              aws apigateway put-method-response \
                --rest-api-id $API_ID \
                --resource-id $RESOURCE_ID \
                --http-method OPTIONS \
                --status-code 200 \
                --response-models '{"application/json":"Empty"}' \
                --response-parameters '{
                  "method.response.header.Access-Control-Allow-Headers":true,
                  "method.response.header.Access-Control-Allow-Methods":true,
                  "method.response.header.Access-Control-Allow-Origin":true
                }' 2>/dev/null || echo "Method response likely exists"
              
              # CONFIGURE OPTIONS MOCK INTEGRATION
              aws apigateway put-integration \
                --rest-api-id $API_ID \
                --resource-id $RESOURCE_ID \
                --http-method OPTIONS \
                --type MOCK \
                --integration-http-method OPTIONS \
                --request-templates '{"application/json":"{\"statusCode\": 200}"}' 2>/dev/null || echo "Integration likely exists"
              
              # CONFIGURE INTEGRATION RESPONSE
              aws apigateway put-integration-response \
                --rest-api-id $API_ID \
                --resource-id $RESOURCE_ID \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters '{
                  "method.response.header.Access-Control-Allow-Headers":"'"'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"'",
                  "method.response.header.Access-Control-Allow-Methods":"'"'GET,POST,PUT,DELETE,OPTIONS,PATCH'"'",
                  "method.response.header.Access-Control-Allow-Origin":"'"'*'"'"
                }' \
                --response-templates '{"application/json":""}' 2>/dev/null || echo "Integration response likely exists"
            done
          fi

      - name: Check if Usage Plan exists
        id: check-usage-plan
        run: |
          # CHECK IF USAGE PLAN EXISTS
          EXISTING_USAGE_PLANS=$(aws apigateway get-usage-plans --query "items[?name=='${{ env.USAGE_PLAN_NAME }}'].id" --output text)

          if [ -n "$EXISTING_USAGE_PLANS" ]; then
            echo "USAGE_PLAN_ID=$EXISTING_USAGE_PLANS" >> $GITHUB_ENV
            echo "usage_plan_exists=true" >> $GITHUB_OUTPUT
          else
            echo "usage_plan_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Usage Plan
        if: steps.check-usage-plan.outputs.usage_plan_exists != 'true'
        run: |
          # CREATE USAGE PLAN
          USAGE_PLAN_RESULT=$(aws apigateway create-usage-plan \
            --name "${{ env.USAGE_PLAN_NAME }}" \
            --description "${{ env.USAGE_PLAN_DESCRIPTION }}" \
            --throttle "rateLimit=${{ env.API_THROTTLE_RATE }},burstLimit=${{ env.API_THROTTLE_BURST }}" \
            --quota "limit=${{ env.API_QUOTA_LIMIT }},period=${{ env.API_QUOTA_PERIOD }}" \
            --api-stages "apiId=$API_ID,stage=prod")

          USAGE_PLAN_ID=$(echo $USAGE_PLAN_RESULT | jq -r '.id')
          echo "USAGE_PLAN_ID=$USAGE_PLAN_ID" >> $GITHUB_ENV

      - name: Check if API Key exists
        id: check-api-key
        run: |
          # CHECK IF API KEY EXISTS
          EXISTING_API_KEY_ID=$(aws apigateway get-api-keys --name-query "${{ env.API_KEY_NAME }}" --include-values --query "items[0].id" --output text)

          if [ "$EXISTING_API_KEY_ID" != "None" ] && [ -n "$EXISTING_API_KEY_ID" ]; then
            echo "API_KEY=$EXISTING_API_KEY_ID" >> $GITHUB_ENV
            echo "api_key_exists=true" >> $GITHUB_OUTPUT
            echo "EXISTING_API_KEY_ID=$EXISTING_API_KEY_ID" >> $GITHUB_ENV
          else
            echo "api_key_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create API Key
        if: steps.check-api-key.outputs.api_key_exists != 'true'
        run: |
          # CREATE API KEY
          API_KEY_RESULT=$(aws apigateway create-api-key \
            --name "${{ env.API_KEY_NAME }}" \
            --description "${{ env.API_KEY_DESCRIPTION }}" \
            --enabled)

          API_KEY=$(echo $API_KEY_RESULT | jq -r '.id')
          echo "API_KEY=$API_KEY" >> $GITHUB_ENV

          # ADD API KEY TO USAGE PLAN
          aws apigateway create-usage-plan-key \
            --usage-plan-id ${{ env.USAGE_PLAN_ID }} \
            --key-id $API_KEY \
            --key-type API_KEY

      - name: Output API URL
        run: |
          # GET API URL
          API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod/"
          echo "::add-mask::$API_URL"

          # RETRIEVE THE API KEY VALUE (MASKED IN LOGS)
          API_KEY_VALUE=$(aws apigateway get-api-key \
            --api-key "$API_KEY" \
            --include-value \
            --query 'value' \
            --output text)

          # MASK API KEY IN LOGS
          echo "::add-mask::$API_KEY_VALUE"

          # DISPLAY NOTICE WITH SECURE INSTRUCTIONS
          echo "::notice title=API Gateway Deployed::API GATEWAY HAS BEEN SUCCESSFULLY DEPLOYED WITH URL: $API_URL"

          if [ -z "$EXISTING_API_KEY_ID" ]; then
            echo "A NEW API KEY HAS BEEN GENERATED. USE THE 'X-API-KEY' HEADER WITH THIS KEY TO ACCESS THE API."
          else
            echo "EXISTING API KEY HAS BEEN REUSED. CONTINUE USING THE SAME API KEY WITH THE 'X-API-KEY' HEADER."
          fi
